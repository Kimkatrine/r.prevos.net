#+TITLE: Getting Started with the R Language: Solving Project Euler Problems to learn to code
#+TODO: TODO DRAFT EDITED FINAL
#+STARTUP: overview
#+PROPERTY: header-args:R :session *R* :results value raw :exports both
#+LATEX_HEADER: \usepackage{times} \usepackage{mathptmx}
#+BEGIN: kanban
| TODO                                              | DRAFT        | EDITED  | FINAL |
|---------------------------------------------------+--------------+---------+-------|
|                                                   |              | [[Preface][Preface]] |       |
|                                                   | [[Introduction][Introduction]] |         |       |
| [[The R Language of Statistical Computing][The R Language of Statistical Computing]]           |              |         |       |
| [[Project Euler][Project Euler]]                                     |              |         |       |
| [[Problem 1: Multiples of 3 or 5][Problem 1: Multiples of 3 or 5]]                    |              |         |       |
| [[Problem 2: Even Fibonacci Numbers][Problem 2: Even Fibonacci Numbers]]                 |              |         |       |
| [[Problem 3: Largest Prime Factor][Problem 3: Largest Prime Factor]]                   |              |         |       |
| [[Problem 4: Largest Palindromic Product][Problem 4: Largest Palindromic Product]]            |              |         |       |
| [[Problem 5: Smallest Multiple][Problem 5: Smallest Multiple]]                      |              |         |       |
| [[Problem 8: Largest product in a series][Problem 8: Largest product in a series]]            |              |         |       |
| [[Problem 6: Euler Problem 6: Sum Square Difference][Problem 6: Euler Problem 6: Sum Square Difference]] |              |         |       |
| [[Problem 7: 10,001st Prime][Problem 7: 10,001st Prime]]                         |              |         |       |
| [[Problem 8: Largest Product in a Series][Problem 8: Largest Product in a Series]]            |              |         |       |
| [[Problem 9: Special Pythagorean Triple][Problem 9: Special Pythagorean Triple]]             |              |         |       |
| [[Problem 10: Summation of primes][Problem 10: Summation of primes]]                   |              |         |       |
| [[Learning mode about R][Learning mode about R]]                             |              |         |       |
| [[Index][Index]]                                             |              |         |       |
#+END:

* EDITED Preface
In the early nineteen eighties, my best friend Leon told me that he knew a computer program. In those days, computers were mythical machines that were only used by scientists and astronauts. The fact that my friend knew a computer program was almost the same as having access to esoteric knowledge. He showed a two-line program on a piece of paper in the BASIC language, the most popular computing language in the 1980s. I had no idea what it meant, but it looked like a magic spell.

#+BEGIN_SRC 
10 PRINT "LEON"
20 GOTO 10
#+END_SRC

This was a time when computers became accessible to the masses through the wave of eight-bit computers such as the Commodore 64. Soon after this experience, I purchased a ZX81 from another friend, and I distinctly remember the first time I booted it. An empty screen with a blinking cursor and a message that there were 1024 bytes of memory available. The ZX81 was the start of a great adventure.

I learned to write code by copying programs from books with computer games. It was a great way to learn the grammar and logic of computing. Rather than starting from scratch, I modified the program from these books and learned by trial and error.

When studying civil engineering, I used my programming skills to solve assignments and wrote simple software to design structures. When I started my career, I stopped writing code I thought that Lotus 123, popular spreadsheet software of those days, was the best thing since sliced bread. A large part of my work as a civil engineer revolved around developing ever-more complex spreadsheets.

Forward more than twenty years, and I found myself in a situation where I was no longer able to use a spreadsheet to meet my engineering needs. I decided to go back to writing code and mastered the R language. This experience was transforming for three reasons. Firstly, writing code is the way computers were intended to be used. Coding gives you freedom instead of using software out of the box. Secondly, computer code is easier to reproduce and reverse-engineer than a spreadsheet. Last but not least, the R language provides access to a vast library of specialised packages to solve complex problems, including some of the most advanced machine learning algorithms.

I now promote the R language to engineers in my industry to reduce our reliance on Microsoft Excel. I have written this book as an interesting introduction into using the R language to solve mathematical problems. If you are interested in my approach to working with the R language, then perhaps you like to follow my /The Devil is in the Data/ blog on [[https://lucidmanager.org/devil-is-in-the-data/][lucidmanager.org]].
* DRAFT Introduction
Most books about programming are quite abstract introductions because the teach the student a lot of computing vocabulary and coding grammar, without real applications. These books are very logical, as you would suspect from a text about programming, but they have a steep learning curve because it takes a long time before you achieve any results.

This book follows a different approach to teaching the R language by solving a series of mathematical problems and explaining the code needed to find the solution. This book is inspired by the great computer game books of the nineteen eighties. Learning how to write code in this manner might be less systematic than standard textbooks, but it provides a faster learning curve because you are solving problems while you learn. This book provides a solid introduction to solving mathematical problems with the R language, but it is only a way to get you started. If, after reading this book, you want to learn more about this language there are many free and paid resources to gain further expertise.
** TODO The R Language of Statistical Computing
R is a computing language specially designed for statistical analysis. 
*** History
*** Purpose and scope
*** R versus Python
One of the favourite discussion points for data scientists is whether you should use Python or R. Python is another open source language 

From my perspective as an engineer
*** Installing the software
To start using R you need two pieces of software. Firstly, you need to install the R language itself. You can download the latest version for your operating system from *

Secondly you will need an IDE (Integrated Development Environment) to make it easier to develop code. The most popular IDE is R Studio, which is free open source, specially designed to manage projects in R.

You can use other IDEs and my weapon of choice is to write code in GNU Emacs. But using Emacs is an adventure in itself which goes beyond the scope in this book.
*** Getting Started
After you have installed these two packages, open R Studio. Your screen is divided in four areas.
** TODO Project Euler
Solving project Euler problems is an amusing way to teach yourself a new programming language. 
Copyright?

Spolier alert

The problems on the The content on the site is licenced under a Creative Commons Licence:
Attribution-NonCommercial-ShareAlike 2.0 UK: England & Wales.
* TODO Problem 1: Multiples of 3 or 5
** Introduction
This first problem is a perfect gentle introduction to solving mathematical problems in with R. 

Listing the natural numbers below 10 that are multiples of 3 or 5 results in the numbers 3, 5, 6 and 9. The sum of these multiples is $3+5+6+9=23$. Your assignment is to write some code to find the sum of all the multiples of 3 or 5 below 1000.

This problem is similar to one posed to the greatest mathematical genius of all times, Carl Friedrich Gauss (1777--1855). When little Carl was ten years old his teacher posed his children a little problem to ponder on. Undoubtedly seeking some quite time for himself, he asked the young students to add all the numbers from 1 to 100.
 
Carl stood up after a few minutes and confidently handed his slate to the teacher with 5050 written in large chalk letters. All the other kids were still diligently adding numbers, so how was Carl able to finish his task so quickly?

The details and full truth of this story are lost in history but we can assume that Carl realised the solution while writing the series forwards ad backwards:

$$1 + 2 + 3 + \ldots + 98 + 99 + 100$$

$$100 + 99 + 98 + \ldots + 3 + 2 + 1$$

Little Gauss obtained the sum of all pairs and noticed a regularity:

$$1 + 100 = 2 + 99 = 3 + 98 = \ldots 100 + 1 = 99 + 2 = 98 + 3 = 101$$

Each of the pairs adds up to 101 and there are 100 pairs, therefore the sum of all numbers is half the sum of all pairs. Gauss was not the first to discover this method. Some thirteen hundred years earlier, Indian mathematician and astronomer Aryabhata described this method in his book.

This anecdote shows that there are two ways to solve this first problem. The brute force method used by Gauss' friends is to list all the multiples of 3 and 5 below 1000 and add them together. This solution requires many steps to find the answer. The smart solution is to use a one-step formula, such as the young Euler and Aryabhata had figured out. This chapter shows different ways to achieve the first solution and the second solution to introduce the basic concepts of solving problems in R.
** Brute Force Solutions
The R language provides several ways to loop through a sequence of numbers. The first method is a for-loop which tests all numbers between 1 and 999. 

The first step is to define a variable to store the answer. R does this with the assignment operator =<-=. The operator can be used in three different ways:

#+BEGIN_SRC R
a <- 10
10 -> b
a <- b <- 10
#+END_SRC

Most other computing languages us the === symbol to assign a value. This operator can also be used in R, but is usually reserved for assigning values in functions.

The second step is to loop through all numbers from 1 to 999 and check if the number is divisible by 3 or 5. R defines a counted loop with the =for= function and a sequence between brackets. All code between the curly brackets is interpreted and the loop is incremented at the end, until the sequence ends.

The example below loops trough the numbers between 1 and 999, indicated by =1:999= in the code. The colon operator is one of several ways to define a sequence of numbers in R. For example =a <- 1:3= assigns a vector with the numbers 1, 2 and 3 to the variable =a=.

In this example, the variable =i= is incremented by 1 every time the code between curly braces is completed, until =i= equals 999.

The third step involves testing if the number in the sequence is divisible by 3 or by 5. If this is the case, then the value of answer is increased by =i=.


[arithmetic]

#+BEGIN_SRC R
  answer <- 0
  for (i in 1:999) {
      if (i %% 3 == 0 | i %% 5 == 0) 
          answer <- answer + i
  }
  print(answer)
#+END_SRC

The next two solutions solve this problem in one line by using vector arithmetic. On of the strengths of R is that calculations can be performed over a complete vector.

First a few words about vectors. We have already seen the colon operator that can be used to create sequences of sequential numbers.

#+BEGIN_SRC R
  sum((1:999)[((1:999) %% 3 == 0) | ((1:999) %% 5 == 0)])
#+END_SRC

#+BEGIN_SRC R
  sum(unique(c(seq(3, 999, 3), seq(5, 999, 5))))
#+END_SRC
** Analytical solution
The three brute-force solutions are swift because of the low number of steps to find a solution. An analytical solution significantly reduces the processing time as it only requires one step.

The problem involves /arithmetic progressions/, which are sequences of numbers with a constant difference. The sequence 1, 4, 7, 10, 13, ... is an arithmetic progression with a common difference of three. 

We can generalise the method discovered by Gauss. The sum of an arithmetic progression (S_n), where $n$ is the number of elements and $a_1$ and $a_n$ are the lowest and highest value, is:

$$S_n= \frac{n(a_{1} + a_n)}{2}$$

The numbers divisible by $n=3$ can be expressed as:

$$\mathrm{sum}_3(999)=3+6+9+12+ \ldots + 999 = 3(1+2+3+4+ \ldots + 333)$$

We can now calculate the sum of all divisors by combining the above progression with the formula for arithmetic progressions as expressed in the above code, where $m$ is the divisor and $n$ the extent of the sequence. $p$ is the highest number less than $n$ divisible by $m$. In the case of 5, this number is 995.

$p = n \lfloor (m/n) \rfloor$

Substitution gives:

$\mathrm{sum}_m(n) =  p \frac{1+(p/m)}{2}$

#+BEGIN_SRC R
  SumDivBy <- function(m, n) {
      p <- floor(n / m) * m # Round to multiple of n
      return (p * (1 + (p / m)) / 2)
  }
  SumDivBy(3, 999) + SumDivBy(5, 999) - SumDivBy(15, 999)
#+END_SRC
** Fizzbuzz
Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.
* TODO Problem 2: Even Fibonacci Numbers
The second Project Euler problem looks at the Fibonacci numbers. These numbers describe many natural processes and can also be used to create magic tricks.

Sunflower experiment
** Problem Definition
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

This problem asks to find the sum of all even Fibonacci numbers less than four million.

This number sequence describes many natural processes, such as the patterns in this beautiful sunflower. The seeds inside the sunflower grow in a spiral pattern and the number of spirals tends to be a Fibonacci number. This pattern is the most efficient way to pack the centre with as many seeds as possible.

Famous mathematician and father of computer science Alan Turing was fascinated by this problem until his death. In 2016, the Royal Society published a journal article that builds on his work in the Open Science journal. They collected sunflowers from citizen scientists from around the world and confirmed that for the majority of sunflowers, the number of spirals is a Fibonacci number. They did, however, also discover other patterns. Euler Problem 2 is a bit less poetic as it only asks to generate and sum numbers.
** More about loops
The first problem introduced using the for-loop to cycle through a series of numbers. The R language has several other ways to cycle 

The code generates Fibonacci numbers until it reaches the value of four million. The code then sums the even numbers in the sequence. Because the Fibonacci sequence requires you to add the previous two number, the first two numbers in the sequence need to be defined (1 and 2). The fib variable is a collection, indicated with the letter =c=. A collection in R can be used to store a sequence of numbers or words.

#+BEGIN_SRC R
  fib <- c(1, 2)
  while (max(fib) < 4E+06) {
      len <- length(fib)
      fib <- c(fib, fib[len - 1] + fib[len])
  }
  answer <- sum(fib[fib %% 2 == 0])
  print(answer)
#+END_SRC

Concatenating a collection in a loop is generally frowned-upon in R programming. This approach is a relatively slow solution because all previous values are rewritten at every iteration. In a future problem we will use lists to avoid this issue.
*** Specialised packages
One of the major advantages of using R are the thousands of specialised packages that can be used to solve specific problems. There are packages that extend the mathematical capabilities of R, etc etc.

A series of R packages exist that generate Fibonacci numbers. The [[https://cran.r-project.org/web/packages/gmp/index.html][GMP package]] for Multiple Precision Arithmetic provides a function to calculate any Fibonacci number. This package is also able to work with huge numbers with hundreds or thousands of digits. Using this package is much faster than the base R code used above.

Before you can start using this package you will need to install it. 

#+BEGIN_SRC R
install.packages("gmp")
#+END_SRC

#+BEGIN_SRC R :tangle problem002.R :results output
  ## GNU Multiple Precision Arithmetic Library
  library(gmp)
  i <- 1
  answer <- 0
  fib <- fibnum(i)
  while (fib <= 4E6) {
      if (fib %% 2 == 0) {
          answer <- answer + fib
          }
      i <- i + 1
      fib <- fibnum(i)
      }
  print(answer)
#+END_SRC

#+RESULTS:
: Big Integer ('bigz') :
: [1] 4613732
* TODO Problem 3: Largest Prime Factor
Euler problem 3 is about prime factors, which are some of the most important numbers of the digital economy. RSA encryption is based on the fact that determining the prime factors of huge numbers takes a very long time. So much time in fact that the cost of breaking the encryption outweigh the benefits of obtaining the secret.

[[https://r.prevos.net/tag/primes/][Prime numbers]] are the basic building blocks of the natural numbers as every number, except the primes themselves. Every natural number can be written as the product of a series of primes. The RSA encryption system uses large primes to keep electronic messages away from prying eyes, as explained in the Numberphile video below.

https://www.youtube.com/watch?v=M7kEpw1tn50
** Euler Problem 3 Definition
The prime factors of 13195 are 5, 7, 13 and 29. What is the [[https://projecteuler.net/problem=3][largest prime factor of the number 600851475143]]?
** Generating Prime Numbers
This solution relies on two functions that can be used for multiple Euler problems. The [[https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes][Sieve of Eratosthenes]] generates prime numbers from 2 to /n/. The code is commented to explain the sieve and the image shows how numbers from 1 to 100 are sieved to find the primes.

https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#/media/File:Sieve_of_Eratosthenes_animation.gif
#+caption: Sieve of Eratosthenes.

The =prime.factors= function generates the list of unique prime divisors and then generates the factors. The factors are identified by dividing the number by the candidate prime factors until the result is 1.

The solution can also be found by using the =primeFactors= function in the [[https://cran.r-project.org/web/packages/numbers/index.html][numbers]] package, which provides a range of functions related to prime numbers and is much faster than the basic code provided above.

The most recent version of this code is available on [[https://github.com/pprevos/r.prevos.net/blob/master/ProjectEuler/problem003.R][GitHub]].

#+BEGIN_SRC R :results output :tangle problem003.R
  ## Euler Problem 3: Largest prime factor
  ## https://r.prevos.net/euler-problem-3/
  esieve <- function(n) {
      if (n == 1) return(NULL)
      if (n == 2) return(n)
      ## Create a list of consecutive integers {2,3,…,N}.
      l <- 2:n
      ## Start counter
      i <- 1
      ## Select p as the first prime number in the list, p=2.
      p <- 2
      while (p^2 <= n) {
          ## Remove all multiples of p from the l.
          l <- l[l == p | l %% p!= 0]
          ## set p equal to the next integer in l which has not been removed.
          i <- i + 1
          ## Repeat steps 3 and 4 until p2 > n,
          ## all the remaining numbers in the list are primes
          p <- l[i]
      }
      return(l)
  }

  prime.factors <- function (n) {
      ## Define list of factors
      factors <- c()
      ## Define primes to be tested
      primes <- esieve(floor(sqrt(n)))
      ## Idenitfy prime divisors
      d <- which(n %% primes == 0) 
      ## No prime divisors
      if (length(d) == 0) 
          return(n)
      ## Test candidate primes
      for (q in primes[d]) {
          ## Generate list of factors
          while (n %% q == 0) {
              factors <- c(factors, q)
              n <- n/q } }
      if (n > 1) factors <- c(factors, n)
      return(factors)
  }

  max(prime.factors(600851475143))

  ## Using number package
  library(numbers)
  max(primeFactors(600851475143))
#+END_SRC

#+RESULTS:
: [1] 6857
: [1] 6857


-------------------------------------------------------------------------------
* TODO Problem 4: Largest Palindromic Product
** Euler Problem 4 Definition
A palindromic number reads the same both ways. The largest [[https://en.wikipedia.org/wiki/Palindromic_number][palindrome]] made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the [[https://projecteuler.net/problem=4][largest palindrome]] made from the product of two 3-digit numbers.
** Solution
This code searches fo palindromic numbers, starting at the highest values. The palindromes are tested by converting the number to a character string. When the first palindromic number is found, the loop is broken.

Searching a bit further results in twelve palindromic numbers. Sequence A002113 in the OEIS lists palindromes in base 10. Mathematicians used these numbers only for fun, without any purpose in reality. The graph below shows the number of palindromic numbers between 0 and 1 million.

#+BEGIN_SRC R :tangle problem004.R :results output graphics :file Images/problem004.png
  ## Euler Problem 4: Largest palindrome product
  ## https://projecteuler.net/problem=4
  library(tidyverse)

  palindrome <- function(x) {
      ## Convert to character
      word <- as.character(x)
      ## Create reverse
      reverse <- paste(rev(unlist(strsplit(word, ""))), collapse = "")
      ## Check whether palindrome
      return(word == reverse)
  }

  for (i in 999:900) {
      for (j in 990:900) {
          p <- i * j
          if (palindrome(p)) 
              break
      }
      if (palindrome(p)) {
          break
      }
  }
  answer <- i * j
  print(answer)

  ## A002113 Palindromes in base 10
  p_max <- 1.5E5
  A002113 <- which(lapply(1:p, palindrome) == TRUE)
  data_frame(x = 1:p_max,
             y = sapply(1:p_max, function(p) length(A002113[A002113 < p]))
             ) %>%
      ggplot(aes(x, y)) + geom_line() +
      xlab("n") + ylab("Palindromic numbers <n")
  ggsave("Images/problem004.png", dpi = 300)
#+END_SRC	

#+RESULTS:
[[file:Images/problem004.png]]
* TODO Problem 5: Smallest Multiple
Euler Problem 5 relates to the divisibility of numbers.
** Euler Problem 5
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
** Solution
The solution will also be divisible by the number 1 to 10 so we can start at 2520 and increment by 2520. The loop checks whether the number is divisible by the numbers 1 to 20.
#+BEGIN_SRC R :tangle problem005.R
## Euler Problem 5: Smallest Multiple
## https://projecteuler.net/problem=4
i <- 2520
while (sum(i %% (1:20)) != 0) {
    i <- i + 2520
}
answer <- i
print(answer)
#+END_SRC

#+RESULTS:
: 232792560

The most recent version of this code is available on [[https://github.com/pprevos/r.prevos.net/blob/master/ProjectEuler/problem005.R][GitHub]].

#+BEGIN_SRC R :tangle problem005.R
## Analytical solution by David Radcliffe
## Euclidean algorithm
gcd = function (x, y) ifelse(x == 0, y, gcd(y %% x, x))
lcm = function (x, y) x*y/gcd(x,y)
print(Reduce(lcm, 1:20))
#+END_SRC

#+RESULTS:
: 232792560
* TODO Problem 8: Largest product in a series
#+BEGIN_SRC R :tangle problem008.R
  ## Euler Problem 8: Largest product in a series
  ## https://projecteuler.net/problem=8
  library(rvest)
  digits <- read_html("https://projecteuler.net/problem=8") %>%
      html_nodes("p") %>%
      html_text() 
  digits <- gsub("[^0-9\\.]", "", digits[2])

  ngram <- 13 # Define length
  answer <- 0
  ## Clycle through digits
  for (i in 1:(nchar(digits) - ngram + 1)) {
      ## Pick 13 consecutive digits
      adjecent <- substr(digits, i, i + ngram - 1)
      ## Define product
      mult <- prod(as.numeric(unlist(strsplit(adjecent, ""))))
      ## Largest?
      if (mult > answer) answer <- mult
  }
  print(answer)
#+END_SRC

#+RESULTS:
: 23514624000
* TODO Problem 6: Euler Problem 6: Sum Square Difference
** Euler Problem 6 Definition
The sum of the squares of the first ten natural numbers is:

$1^2 + 2^2 + \ldots + 10^2 = 385$

The square of the sum of the first ten natural numbers is:

$(1 + 2 + \ldots + 10)^2 = 552 = 3025$

The difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 - 385 = 2640$. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
** Solution
This is a straightforward problem for vector processing capabilities in R.

#+BEGIN_SRC R :tangle problem006.R :results output 
  ## Euler Problem 6: Sum Square Difference
  ## https://projecteuler.net/problem=6

  ## Brute force
  n <- 100
  answer <- sum(1:n)^2-sum((1:n)^2)
  print(answer)

  ## Analytical
  answer <- ((n*(n+1))/2)^2 - (n*(n+1)*(2*n+1))/6
  print(answer)
#+END_SRC

#+RESULTS:
: [1] 25164150
: [1] 25164150

This problem can also be solved arithmetically. When Carl Friedrich Gauss (1777-1855) when he was a child his teacher challenged his students to add all numbers from 1 to 100. All of his friends struggled to add all the 100 numbers one by one but Carl completed the task in a few seconds.

The same principle applies to computing. The first solution is like Carl's classmates who slavishly add all numbers. This solution is based on arithmetic progressions.

The sum of natural numbers can be expressed as:
$latex \frac{n(n + 1)}{2} &s=2$

The sum of the squares of the first n natural numbers is:
$latex \frac{n(n+1)(2n+1)}{6} &s=2$

With these two formulas, a fast solution without having to use loops can be written.

This code on [[https://github.com/pprevos/r.prevos.net/blob/master/ProjectEuler/problem006.R][GitHub]].
* TODO Problem 7: 10,001st Prime
** Euler Problem 7 Definition
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 1,0001st prime number?
** Solution
The =is.prime= function determines whether a number is a prime number by checking that it is not divisible by any prime number up to the square root of the number.

The Sieve of used in Euler Problem 3 is reused to generate prime numbers.

This problem can only be solved using brute force because prime gaps (sequence A001223 in the OEIS) do not follow a predictable pattern.

#+BEGIN_SRC R :tangle problem007.R :results output 
  ## Euler Problem 7: 10,001st Prime
  ## https://projecteuler.net/problem=7

  source("euler.R")
  is.prime <- function(n) {
      primes <- esieve(ceiling(sqrt(n)))
      prod(n %% primes!=0)==1
  }

  i <- 2 # First Prime
  n <- 1 # Start counter
  while (n < 10001) { # Find 10001 prime numbers
      i <- i + 1 # Next number
      if(is.prime(i)) { # Test next number
          n <- n + 1 # Increment counter
          i <- i + 1 # Next prime is at least two away
      }
  }
  answer <- i - 1
  print(answer)

  ## Visualise
  primes <- esieve(answer)
  gaps <- primes[2:10001] - primes[1:10000]

  library(tidyverse)

  data_frame(gap = gaps) %>%
      ggplot(aes(gap)) +
      geom_histogram(binwidth = 1, fill = "dodgerblue3") +
      xlab("Prime gap occurence")
  ggsave("Images/problem007.png", dpi = 300)
#+END_SRC	

#+RESULTS:

The largest prime gap for the first 10,001 primes is 72. Sexy primes with a gap of 6 are the most common and there are 1270 twin primes.

You can also view this code on GitHub.
* TODO Problem 8: Largest Product in a Series
Euler Problem 8 combines mathematics with text analysis. Just like problem 11, it asks for the largest product. The problem is defined as follows: The four adjacent digits in the 1,000-digit number below that have the greatest product are 9 \times 9 \times 8 \times 9 = 5832.

7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1,000-digit number that have the greatest product. What is the value of this product?
Euler Problem 8 Proposed Solution

The first step is to define the digits as a character string. The answer is found by cycling through all 13-character n-grams to find the highest product using the prod function. You can download the most recent version of this code from GitHub.

#+BEGIN_SRC R
# Define digits
digits <- "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
ngram <- 13 # Define length
answer <- 0
# Clycle through digits
    for (i in 1:(nchar(digits) - ngram + 1)) {
    # Pick 13 consecutive digits
    adjecent <- substr(digits, i, i + ngram - 1)
    # Define product
    mult <- prod(as.numeric(unlist(strsplit(adjecent, "")))) # Largest? 
    if (mult > answer)
        answer <- mult
}
#+END_SRC
* TODO Problem 9: Special Pythagorean Triple
Euler Problem 9 is about the ancient problem or Pythagorean triples. My background is in carpentry and the basic Pythagorean triple 3:4:5 is a common tool to check whether an angle is straight. When building a structure, simply mark 3 and 4 units of length on the two sides and check whether the diagonal is exactly five units to ensure your angles are straight. There are, however, an infinite number of triples that form right angles.
Euler Problem 9 Definition

A Pythagorean triple is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2. For example: 3^2 + 4^2 = 9 + 16 = 25 = 5^2. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product of a, b and c.
Brute Force Solutions

This solution uses brute force and checks all combinations of a, b and c. To limit the solution space I used the fact that a < b < c, which implies that a < s/3,  and a < b < s/2, where s is the sum of the three sides.
	
a <- 0
b <- 0
c <- 0
s <- 1000
found <- FALSE
for (a in 1:floor((s / 3))) {
    for (b in a:(s / 2)) {
        c <- s - a - b
        if (a^2 + b^2 == c^2) {
            found <- TRUE
            break
        }
    }
    if (found) break
}
answer <- a * b * c
print(answer)
 
# Improved Brute Force
a <- 1
b <- 499
repeat{
    c <- sqrt(a^2 + b^2) 
    if (a + b + c > 1000) {b <- b - 1}
    else if (a + b + c < 1000) {a <- a + 1}
    else if (a + b + c == 1000) {break}
}
answer <- a * b * c
print(answer)
** Euclid’s Method
Euclid’s formula generates Pythagorean triples for an arbitrary pair of integers m and n with m > n > 0. The formula states that the integers a = m^2 - n^2, b = 2mn, c = m^2 = n^2 form a Pythagorean triple. View the code below or download the most recent version from GitHub.

#+BEGIN_SRC R
abcsum <- 1000
x <- abcsum / 2
min <- floor(sqrt(x / 2))
max <- ceiling(sqrt(x))
m <- min:max
m <- m[x %% m == 0]
n <- ((x / m) - m)
a <- 2 * m * n
b <- m^2 - n^2
c <- m^2 + n^2
answer <- a * b * c
print(answer)
#+END_SRC
Scatter plot of the legs (a, b) of the first Pythagorean triples with a and b less than 6000. Negative values are included to illustrate the parabolic patterns. By Dearjean13 CC BY-SA 4.0.
* TODO Problem 10: Summation of primes
:PROPERTIES:
:ORDERED:  t
:END:
Euler Problem 10 asks for the summation of primes. Computationally this is a simple problem because we can re-use the prime sieve developed for Euler Problem 3. When generating a large number of primes the erratic pattern at which they occur is much more interesting than their sum. Mathematicians consider primes the basic building blocks of number theory. No matter how hard we look, however, they do not seem to obey any logical sequence.
The summing of primes reveals an interesting problem in mathematics. Goldbach’s conjecture is one of the oldest and best-known unsolved problems in number theory and states that:

    Every even integer greater than 2 can be expressed as the sum of two primes.

Note that this conjecture is only about even numbers. Goldbach also theorised that every odd composite number can be written as the sum of a prime and twice a square.
** Euler Problem 10 Definition

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.
Solution

The sieve of Eratosthenes function used in Euler Problem 3 can be reused once again to generate the prime numbers between two and two million. An interesting problem occurs when I run the code. When I sum all the primes without the as.numeric conversion, R throws an integer overflow error and recommends the conversion. You can download this code from GitHub.

#+BEGIN_SRC R
primes <- esieve(2e6)
answer <- (sum(as.numeric(primes)))
print(answer)
#+END_SRC
* TODO Learning mode about R
* TODO Index
| Topic      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|------------+---+---+---+---+---+---+---+---+---+----|
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Arithmetic.html][Arithmetic]] | X |   |   |   |   |   |   |   |   |    |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html][Assignment]] | X |   |   |   |   |   |   |   |   |    |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Comparison.html][Comparison]] | X |   |   |   |   |   |   |   |   |    |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Control.html][For]]        | X |   |   |   |   |   |   |   |   |    |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Colon.html][Colon]]      | X |   |   |   |   |   |   |   |   |    |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Control.html][While]]      |   | X |   |   |   |   |   |   |   |    |
| sum        |   | X |   |   |   |   |   |   |   |    |
| max        |   | X |   |   |   |   |   |   |   |    |
| collection |   | X |   |   |   |   |   |   |   |    |

